
//this file defines the grammar for the dragon language.

//it is sometimes inconsistent with the AST Node classes in src/ , but 
//the goal is for both to be consistent with each other

//the language can be written with indentation, or with curly braces,
//depending on your preferences. before lexing, 
//if there is indentation, it is replaced with curly braces
//so everything after that brace-weaving recognizes only the curly braces variation

//TODO: think about how to parse statements in method,
//if the semicolons should perhaps be weaved in also or if we can do it otherwise

//using regex notation , so '?' at the end means optional, and '+' means once or more
//TODO
//-----------------------------------------------------------------------------

int ::= ... | -1 | 0 | 1 | 2 | ...
char ::= 'a' | ... | 'z' | 'A' | ... | 'Z' | '_'
alphanumeric ::= int | char
identifier ::= char alphanumeric*
string ::= '"' alphanumeric* '"'

op ::= '+' | '-' | '*' | '/' | ...
unaryOp ::= '-' | '!'
booleanConstant ::= 'true' | 'false'
keywordConstant ::= 'null' | 'this' | booleanConstant
accessmodifier ::= public | private

class ::= accessmodifier class identifier '{' classField* method* '}'

classField ::= accessmodifier? Type identifier ';'

Type ::= identifier

variable ::= identifier

methodName ::= identifier

method ::= accessmodifier returnType methodName '(' declaredArgument* ')' '{' statement* '}'

method ::= accessmodifier methodName '::' (Type smallarrow)* Type '{' statement* '}'

smallarrow ::= '->'

returnType ::= 'void' | Type

declaredArgument ::= Type identifier

statement ::= ( methodCall | whileStatement | ifStatement | assignmentStatement | returnStatement ) ';'

methodCall ::= identifier '(' ( (string (, string)*) | string ) ')'

whileStatement ::= 'while' '(' expression ')' '{' statement* '}'

ifStatement ::= 'if' '(' expression ')' '{' statement* '}' ( 'else' '{' statement* '}' )?

returnStatement ::= 'return' expression ';'

assignmentStatement ::= variable ('<-' | '=') expression ';'

term ::= integerConstant | string | keywordConstant | methodCall | '(' expression ')' | unaryOp term

expression ::= term (op term)*