
//this file defines the grammar for the dragon language.

//it is sometimes inconsistent with the AST Node classes in src/ , but 
//the goal is for both to be consistent with each other

//the language can be written with indentation, or with curly braces,
//depending on your preferences. before lexing, 
//if there is indentation, it is replaced with curly braces
//so everything after that brace-weaving recognizes only the curly braces variation

//TODO: think about how to parse statements in method,
//if the semicolons should perhaps be weaved in also or if we can do it otherwise

//using regex notation , so '?' at the end means optional, and '+' means once or more
//TODO
//-----------------------------------------------------------------------------

int ::= ... | -1 | 0 | 1 | 2 | ...
char ::= 'a' | ... | 'z' | 'A' | ... | 'Z' | '_'
alphanumeric ::= int | char
identifier ::= char alphanumeric*
string ::= '"' alphanumeric* '"'

op ::= '+' | '-' | '*' | '/' | ...
unaryOp ::= '-' | '!'
boolConstant ::= 'true' | 'false'

arrayConstant ::= '[' expression (',' expression)* ']'

keywordConstant ::= 'null' | 'this' | booleanConstant
accessmodifier ::= public | private

class ::= accessmodifier? class identifier '{' compilerDirective*  classField* method* '}'

compilerDirective ::= 'includestatic' PATH ';' //any valid path to a .dg file. PATH is a string token

classField ::= accessmodifier? Type identifier ';'

Type ::= identifier 

variable ::= identifier ('[' expression ']')?

methodName ::= identifier

//i want to split it into Void method and Value Method
//and ... wait ... what if we eliminate Void from the language? that would
//make so many things easier since every method and every function would return a value
//and a programmer could simply make the method as Int and return 0;
//maybe that could be integrated into the Void method/function

method ::= accessmodifier Type methodName '(' declaredArgument* ')' '{' statement* '}'

// // functions are always public
//functionTypeDecl ::= functionName '::' (Type '->')* Type
// // like in haskell, there should be pattern matching available, so multiple definitions depending
// // on the value of the pattern
//function ::= functionName identifier* = value
//value ::= arrayConstant | boolConstant | integerConstant | string | keywordConstant | functionCall | value
//functionName ::= identifier
//functionCall ::= functionName expression*

declaredArgument ::= Type identifier

//some of these have the semicolon themselves,
statement ::= ( methodCall ';' | whileStatement | ifStatement | returnStatement | assignmentStatement )

methodCall ::= methodName '(' (expression (, expression)*)?  ')'

loopStatement ::= 'loop' expression '{' statement* '}'
whileStatement ::= 'while' '(' expression ')' '{' statement* '}'
ifStatement ::= 'if' '(' expression ')' '{' statement* '}' ( 'else' '{' statement* '}' )?
returnStatement ::= 'return' expression? ';'

assignmentStatement ::= objectOrVariable '=' expression ';'

term ::= arrayConstant | boolConstant | integerConstant | string | keywordConstant | methodCall | '(' expression ')' | unaryOp term | variable

expression ::= term (op term)*



//TODO: these rules below are speculation. they are not yet in the language
object ::= identifier
objectOrVariable ::= variable | fieldAccess | object
fieldAccess ::= object '.' object | object '.' methodCall | methodCall '.' object
