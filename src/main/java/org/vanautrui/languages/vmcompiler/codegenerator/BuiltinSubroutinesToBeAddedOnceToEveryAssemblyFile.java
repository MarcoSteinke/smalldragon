package org.vanautrui.languages.vmcompiler.codegenerator;

import org.vanautrui.languages.compiler.vmcodegenerator.DracoVMCodeWriter;
import org.vanautrui.languages.vmcompiler.AssemblyWriter;
import org.vanautrui.languages.vmcompiler.instructions.VMInstr;
import org.vanautrui.languages.vmcompiler.model.Register;

import static org.vanautrui.languages.vmcompiler.model.Register.*;
import static org.vanautrui.languages.vmcompiler.model.Register.ecx;

/**
 * contains the builtin subroutines of dragon, in assembly.
 * These subroutines are to be added at the end of the code to every .asm file generated by the dragon vm compiler.
 *
 * These subroutines must behave like any other subroutine when called.
 */
public class BuiltinSubroutinesToBeAddedOnceToEveryAssemblyFile {

  public static void compile_putchar(AssemblyWriter a)throws Exception{
    //prints top of stack as ascii char to stdout

    SubroutineFocusedAssemblyCodeGenerator.compile_subroutine("putchar",a);

    //access our argument , ARG 0, by pushing it onto the stack
    AssemblyCodeGenerator.compile_push(DracoVMCodeWriter.SEGMENT_ARG,0,a);

    a.mov(eax,4,"putchar: sys_write");
    a.mov(ebx,1,"putchar: std_out");

    //print the char on stack
    a.mov(ecx, esp,"putchar: print the char on the stack");


    //val length
    a.mov(Register.edx,1,"putchar: value length");
    a.call_kernel();

    //remove our argument which we had pushed
    a.pop(eax,"putchar: remove the ARG 0 which we had pushed");

    //push return value
    a.mov(Register.edx,0,"putchar: push return value");
    a.push(Register.edx,"putchar: push return value");

    //we must swap return value with the return address in order to return
    //(i am so dumb. took me so long to find this.)
    AssemblyCodeGenerator.compile_swap("swap return address with return value to return",a);

    //return from subroutine
    SubroutineFocusedAssemblyCodeGenerator.compile_return(a);
  }

  public static void compile_putdigit(AssemblyWriter a) throws Exception{
    //prints the Int on top of stack as char to stdout
    SubroutineFocusedAssemblyCodeGenerator.compile_subroutine("putdigit",a);
    final String name="putdigit";

    //access our argument , ARG 0, by pushing it onto the stack
    AssemblyCodeGenerator.compile_push(DracoVMCodeWriter.SEGMENT_ARG,0,a);

    a.mov(eax,4,name+" sys_write");
    a.mov(ebx,1,name+" std_out");

    //duplicate the value on stack, add offset to make it a char
    a.pop(ecx);
    a.push(ecx);
    a.add(ecx,48,name+" add offset to make it char");
    a.push(ecx);

    a.mov(ecx, esp,name+" print the Int on the stack");

    //val length
    a.mov(Register.edx,1,name+" value length");
    a.call_kernel();

    //pop that value which we pushed
    a.pop(ecx);

    //pop ARG 0 which we pushed
    a.pop(ecx);

    //push return value
    a.mov(Register.edx,0,name+" push return value");
    a.push(Register.edx,name+" push return value");

    //we must swap return value with the return address in order to return
    //(i am so dumb. took me so long to find this.)
    AssemblyCodeGenerator.compile_swap("swap return address with return value to return",a);

    SubroutineFocusedAssemblyCodeGenerator.compile_return(a);
  }

  private static void compile_float2int(VMInstr instr, AssemblyWriter a) throws Exception{
    throw new Exception("unhandled");
  }

  private static void compile_int2float(VMInstr instr, AssemblyWriter a) throws Exception{
    throw new Exception("unhandled");
  }

  private static void compile_int2char(VMInstr instr, AssemblyWriter a) throws Exception{
    throw new Exception("unhandled");
  }

  private static void compile_readint(VMInstr instr, AssemblyWriter a)throws Exception{
    throw new Exception("unhandled");
  }
}
