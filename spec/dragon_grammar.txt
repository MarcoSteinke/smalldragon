
//inspiration: https://docs.oracle.com/javase/specs/jls/se7/html/jls-18.html

//this file defines the grammar for the dragon language.

//it is sometimes inconsistent with the AST Node classes in src/ , but 
//the goal is for both to be consistent with each other

//using regex notation , so '?' at the end means optional, and '+' means once or more
//TODO
//-----------------------------------------------------------------------------

int ::= ... | -1 | 0 | 1 | 2 | ...
charConstant ::= 'a' | ... | 'z' | 'A' | ... | 'Z'
alphanumeric ::= int | charConstant | '_'
identifier ::= charConstant alphanumeric*

op ::= '+' | '-' | '*' | '/' | ...
unaryOp ::= '-' | '!'
boolConstant ::= 'true' | 'false'

arrayConstant ::= '[' expression (',' expression)* ']'

keywordConstant ::= 'null' | 'this' | booleanConstant
accessmodifier ::= public | private

//this is the root AST Node
AST ::= class+

class ::= accessmodifier? class identifier '{' classField* method* '}'

classField ::= accessmodifier? Type identifier ';'

Type ::= identifier 
//TODO: implement below changes
simplevariable ::= identifier ('[' expression ']')?

//the variable should not have a method call at the end, because that is not something you can assign to.
//TODO: implement below changes
variable ::= simplevariable | variable '.' variable | methodCall '.' variable

methodName ::= identifier

//i want to split it into Void method and Value Method
//and ... wait ... what if we eliminate Void from the language? that would
//make so many things easier since every method and every function would return a value
//and a programmer could simply make the method as Int and return 0;
//maybe that could be integrated into the Void method/function

method ::= accessmodifier Type methodName '(' declaredArgument* ')' '{' statement* '}'


// // functions are always public
//functionTypeDecl ::= functionName '::' (Type '->')* Type
// // like in haskell, there should be pattern matching available, so multiple definitions depending
// // on the value of the pattern
//function ::= namedFunction | anonFunction
//namedFunction ::= functionName identifier* = value
//value ::= arrayConstant | boolConstant | integerConstant | string | keywordConstant | functionCall | value op value | ...
//functionName ::= identifier
//functionCall ::= functionName expression*
//anonFunction ::= '\' declaredArgument* '->' value

declaredArgument ::= Type identifier

//some of these have the semicolon themselves,
statement ::= ( methodCall ';' | whileStatement | ifStatement | returnStatement | assignmentStatement )
//TODO: implement below changes
methodCall ::= variable? . methodName '(' (expression (, expression)*)?  ')'

loopStatement ::= 'loop' expression '{' statement* '}'
whileStatement ::= 'while' '(' expression ')' '{' statement* '}'
ifStatement ::= 'if' '(' expression ')' '{' statement* '}' ( 'else' '{' statement* '}' )?
returnStatement ::= 'return' expression? ';'

assignmentStatement ::= variable '=' expression ';'

term ::= arrayConstant | boolConstant | integerConstant | charConstant | keywordConstant | methodCall | '(' expression ')' | unaryOp term | variable

expression ::= term (op term)*



//TODO: READ: IMPORTANT: these rules below are speculation. they are not yet in the language
object ::= variable
objectOrVariable ::= variable | fieldAccess | object
fieldAccess ::= object '.' object | object '.' methodCall | methodCall '.' object

//this is a kind of expression inspired by haskell.
//it is similar to the ternary operator
//maybe i should implement them
ifThenElse ::= 'if' expression 'then' expression 'else' expression













