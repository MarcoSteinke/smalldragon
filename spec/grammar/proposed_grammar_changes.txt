//PLANNED FOR NEXT GRAMMAR CHANGE

struct ::= 'struct' identifier '{' declaredArgument (',' declaredArgument)* '}'

//PLANNED FOR LATER

simplevariable ::= identifier ('[' expression ']')?

variable ::= simplevariable | variable '.' variable | methodCall '.' variable

methodCall ::= variable? . methodName '(' (expression (, expression)*)?  ')'

//PLANNED FOR LATER


//MAYBE

//this is a kind of expression inspired by haskell.
//it is similar to the ternary operator
//maybe i should implement them
ifThenElse ::= 'if' expression 'then' expression 'else' expression


// // functions are always public
//functionTypeDecl ::= functionName '::' (Type '->')* Type
// // like in haskell, there should be pattern matching available, so multiple definitions depending
// // on the value of the pattern
//function ::= namedFunction | anonFunction
//namedFunction ::= functionName identifier* = value
//value ::= arrayConstant | boolConstant | integerConstant | string | keywordConstant | functionCall | value op value | ...
//functionName ::= identifier
//functionCall ::= functionName expression*
//anonFunction ::= '\' declaredArgument* '->' value