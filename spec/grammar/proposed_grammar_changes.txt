//PLANNED FOR NEXT GRAMMAR CHANGE

//PLANNED FOR LATER

variable ::= identifier

memberAccess ::= ('[' expression ']')? | '.' variable

assignmentStatement ::= variable '=' expression ';'

Term ::= ArrayConstant | boolConstant | integerConstant | charConstant | keywordConstant | methodCall | '(' expression ')' | unaryOp term | variable

expression ::= Term (op Term)*
//('[' expression ']')?


//simplevariable ::= identifier ('[' expression ']')?

//variable ::= simplevariable | simplevariable '.' variable | methodCall '.' variable



//PLANNED FOR LATER


//MAYBE

//this is a kind of expression inspired by haskell.
//it is similar to the ternary operator
//maybe i should implement them
ifThenElse ::= 'if' expression 'then' expression 'else' expression


// // functions are always public
//functionTypeDecl ::= functionName '::' (Type '->')* Type
// // like in haskell, there should be pattern matching available, so multiple definitions depending
// // on the value of the pattern
//function ::= namedFunction | anonFunction
//namedFunction ::= functionName identifier* = value
//value ::= arrayConstant | boolConstant | integerConstant | string | keywordConstant | functionCall | value op value | ...
//functionName ::= identifier
//functionCall ::= functionName expression*
//anonFunction ::= '\' declaredArgument* '->' value
