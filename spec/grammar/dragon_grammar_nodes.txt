
ArrayConstant ::= '[' expression (',' expression)* ']'

AST ::= namespace+

namespace ::= accessmodifier? 'namespace' SimpleType '{' structDecl* method* '}'

structDecl ::= 'struct' SimpleType '{' structMemberDecl (',' structMemberDecl)* '}'

structMemberDecl ::= Type identifier

SubroutineType ::= '(' Type* ')' arrow Type
SimpleType ::= upperCaseLetter alphanumeric*
BasicTypeWrapped ::= SimpleType | '(' SubroutineType ')'

TypeParameter ::= '?T' ( 0 | 1 | ... )

ArrayType :: = '[' Type ']'

Type ::= BasicTypeWrapped | TypeParameter | ArrayType

variable ::= identifier ('[' expression ']')?

method ::= accessmodifier '(' declaredArgument* ')' arrow Type identifier '{' statement* '}'

declaredArgument ::= Type identifier? //just Type is there to support for example the " (?T0,PInt size)~>[?T0] newarray{...} " builtin subroutine.
                                      //in that case we receive just the type as a parameter, not an instance of it.

statement ::= ( methodCall ';' | whileStatement | ifStatement | returnStatement | assignmentStatement )

methodCall ::= identifier '(' (expression (, expression)*)?  ')'

loopStatement ::= 'loop' expression '{' statement* '}'
whileStatement ::= 'while' '(' expression ')' '{' statement* '}'
ifStatement ::= 'if' '(' expression ')' '{' statement* '}' ( 'else' '{' statement* '}' )?
returnStatement ::= 'return' expression? ';'

assignmentStatement ::= variable '=' expression ';'

Term ::= ArrayConstant | boolConstant | integerConstant | charConstant | methodCall | '(' expression ')' | variable

expression ::= Term (op Term)*













