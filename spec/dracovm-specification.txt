
DracoVM is supposed to be a stack based, compiled VM Language.
It is ispired by the Jack VM (from Nand2Tetris)

Commands supported:
(for now commands support just integers)

hypothetical STACK:
x
a
b

the RETURNS is what is left on the stack after operands have been popped
1 means true,
0 means false

	COMMAND	RETURNS	COMMENT
	add	a+b	integer addition
	sub	a-b	integer subtraction
	neg	-b	integer inversion
	eq	1 or 0	equality
	gt	1 or 0 	>
	lt	1 or 0	<
	geq	1 or 0	>=
	leq	1 or 0	<=

	and	1 or 0	conjunction
	or	1 or 0	disjunction
	not	1 or 0	negation

	inc	tos+1	increment top of stack
	dec	tos-1	decrement top of stack

VIRTUAL MEMORY SEGMENTS
	the DracoVM manipulates various virtual memory segments
	these memory segments have pointers which have a constant address in virtual memory
	and can be used to access these segments
	ARG and LOCAL are on the stack, STATIC is in the .bss or .data segment probably

	ARG	arguments to the subroutine
	LOCAL	local variables for the subroutine
	STATIC	static variables which have a constant virtual memory address


ACCESSING MEMORY SEGMENTS:
	iconst	n		//push a constant integer on the stack
	cconst  c		//pushes a literal character value onto the stack, by converting it
				//to it's ascii code
	fconst	x		//push a float constant on the stack

	push 	SEGMENT index
	pop 	SEGMENT index

	pop 			//just pop the top item off the stack
	dup			//duplicates the top of stack


PROGRAM FLOW COMMANDS:
	label	SYMBOL  //globally unique label for jumping
	goto 	SYMBOL  //jump to a label specified earlier
	if-goto	SYMBOL  //jumps to that label if TOP OF STACK is true (1)
			//also pops the top of stack

SUBROUTINE CALLING COMMANDS:
	subroutine	SUBRNAME NARGS args NLOCALS locals
			//subroutine label with the number of local variables and number of arguments declared

	call 		SUBRNAME 
			//call a subroutine. the arguments should have been pushed on the stack first

	return
	//transfer control back to the calling function
	exit		//exits from the program, the exit status code is the top of stack
			//top of stack==0 if successful
//all subroutines must always leave 1 return
//value on the stack


MEMORY ALLOCATION/DEALLOCTAION:
	malloc	AMOUNT 	
	//amount is the amount of DWORDs (4 Bytes) to be reserved
	//this is because our language currently operates in 32 bit mode
	//this instructions takes 1 argument on the stack and returns one argument on the stack
	//the return address is the address of the allocated memory

	free	ADDRESS
	//deallocates the previously allocated block of memory at that address

BUILTIN SUBROUTINES:
			//these builtin subroutines are considered essential
			//there should be no unneccessary subroutines here			
	putchar		//prints the char on top of stack, the basis for all output

	readint		//reads an integer from stdin, pushes it on the stack.

	int2char	//converts an integer to its asciichar equivalent
			//it takes the top of stack, pops it, converts it to char
			//then pushes it
	
	float2int	//these explain themselves,
	int2float	//and just change the top of stack from one to the other type


CALLING CONVENTIONS:
first, all the arguments to a subroutine are pushed on the stack,
in reverse order.

//dracovm should use the c calling convention for now, to be compatible with C.
//if that causes problems later on then we have to give it up and do our own thing

//good explanation of c calling conventions:
//https://norasandler.com/2018/06/27/Write-a-Compiler-9.html
